import "src/stdlib/types.lang"

print a = (HFI print [a])
debugEnv a = (HFI debugEnv [a])
getArgs = (HFI getArgs [])
debug debugString outVal = (HFI debug [debugString, outVal])

not b = !b
const b _ = b
empty? [] = true
empty? s = false
notEmpty? s = !(empty? s)
head [] = None
head (x::_) = Some x
zipWith f (x::xs) (y::ys) = f x y :: zipWith f xs ys
zipWith _ [] _ = []
zipWith _ _ [] = []
zip xs ys = zipWith (x y: (x, y)) xs ys

sort [] = []
sort (y::xs) = let smaller = filter (a: a <= y) xs,
                    larger = filter (a: a > y) xs:
                  sort smaller ++ [y] ++ sort larger

maybe default f None = default
maybe default f (Some x) = Some (f x)

either ef of e = case e {
  Err x: Err (ef x)
  Ok x: Ok (of x)
}

at Integer, [a] => Maybe a
at i xs =
  zip xs (0 .. length xs)
  |> find ((a, b): b == i)
at i [] = None

even? n = n % 2 == 0
odd? n = not (odd? n)

// FILES
module File {
  readFile p = (HFI readFile [p])
  writeFile path body = (HFI writeFile [path, body])
}

module JSON {
  parse json = (HFI decodeJSON [json])
  decode json = parse json
  toJSON a = (HFI encodeJSON [a])
  encode a = toJSON a
}
// DICTIONARIES
module Dict {
  toList xs = (HFI dictToList [xs])
  keys dict = toList dict |> map ((a, b): a)
  values dict = toList dict |> map ((a, b): b)
  merge d1 d2 = { d1 | d2 }
}

module HTTP {
  get url = (HFI httpRequest [url, "GET", ""])
  post url body = (HFI httpRequest [url, "POST", body])
}
