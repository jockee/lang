fold f init xs := (InternalFunction foldy [f, init, xs]);
// fold f init xs := foldInternal f init xs;
map k ys := fold (acc y: (acc ++ [k y])) [] ys;
filter f xs := foldInternal (acc x: (f x) ? (acc ++ [x]) : acc) [] xs;
reject f xs := foldInternal (acc x: (f x) ? acc : (acc ++ [x])) [] xs;
length xs := foldInternal (acc x: acc + 1) 0 xs;
take n xs := foldInternal (acc x: (n >= x) ? (acc ++ [x]) : acc) [] xs;
empty? xs := xs == [];
// empty? [] := true
// empty? s := false
includes? x xs := foldInternal (acc p: (p == x) ? true : false) false xs;
unique xs := foldInternal (acc x: (includes? x acc) ? acc : (acc ++ [x])) [] xs;
head xs := (InternalFunction head xs);
sort xs := (InternalFunction sort xs); // NOTE: implement without internal?
reverse xs := foldInternal (acc x: [x] ++ acc) [] xs;
max xs := sort xs |> reverse |> head;
min xs := sort xs |> head;

// zip
// merge
// keys
// values

// partial
  // list `at`
  // last
  // find
  // min
  // max
