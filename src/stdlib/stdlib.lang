fold q init qqs := (InternalFunction fold [q, init, qqs]);
// fold f init xs := foldInternal f init xs;
map k xs := fold (acc x: (acc ++ [k x])) [] xs;
filter f xs := fold (acc x: (f x) ? (acc ++ [x]) : acc) [] xs;
reject f xs := fold (acc x: (f x) ? acc : (acc ++ [x])) [] xs;
length xs := fold (acc x: acc + 1) 0 xs;
take n xs := fold (acc x: (n >= x) ? (acc ++ [x]) : acc) [] xs;
empty? xs := xs == [];
// empty? [] := true
// empty? s := false
includes? x xs := fold (acc p: (p == x) ? true : false) false xs;
unique xs := fold (acc x: (includes? x acc) ? acc : (acc ++ [x])) [] xs;
head xs := (InternalFunction head xs);
sort xs := (InternalFunction sort xs); // NOTE: implement without internal?
reverse xs := fold (acc x: [x] ++ acc) [] xs;
max xs := sort xs |> reverse |> head;
min xs := sort xs |> head;

// zip
// merge
// keys
// values

// partial
  // list `at`
  // last
  // find
  // min
  // max
