parseJSON json = (InternalFunction parseJSON [json])
toJSON a = (InternalFunction toJSON [a])
print a = (InternalFunction print [a])
getArgs = (InternalFunction getArgs [])
debug debugString outVal = (InternalFunction debug [debugString, outVal])

not b = !b
empty? [] = true
// empty? "" = false
empty? s = false
head [] = None
head (x::_) = Some x
sort xs = (InternalFunction sort xs) // NOTE: implement without internal?
zipWith f xs ys = (InternalFunction zipWith [f, xs, ys])
zip xs ys = zipWith (x y: (x, y)) xs ys
toDict xs = fold (acc (k, v): { acc | { k => v } }) {} xs

sortt [] = []
sortt (x::xs) = let smaller = (filter (a: a <= x) xs), larger = (filter (a: a > x) xs): (sortt
smaller) ++ [x] ++ (sortt larger)

// DICTIONARIES
toList xs = (InternalFunction dictToList [xs])
keys dict = toList dict |> map ((a, b): a)
values dict = toList dict |> map ((a, b): b)
merge d1 d2 = { d1 | d2 }

maybe default f None = default
maybe default f (Some x) = Some (f x)

either ef of e = case e: | (Err x): Err (ef x) | (Ok x): Ok (of x);

at # Integer, [a]: Maybe a
at i xs =
  zip xs (0 .. (length xs))
  |> find ((a, b): b == i)
at i [] = None

even? n = n % 2 == 0
odd? n = !(odd? n)

// FILES
readFile p = (InternalFunction readFile [p])
writeFile path body = (InternalFunction writeFile [path, body])

  // required comment :-)
