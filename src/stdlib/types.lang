data Maybe = Some a | None
data Result = Ok a | Err b

trait Functor f {
  fmap (a: b), f a => f b
  fmap => (a: b)
}

trait Applicative f {
  ap f (a: b), f a => f b
  pure a => f a
}

trait Monad m {
  bind m a, (a: m b) => m b
}

implement Functor for List {
  fmap _ [] = []
  fmap i (h::hs) = f h :: fmap i hs
}

implement Functor for Maybe {
  fmap _ None = None
  fmap f (Some x) = Some (f x)
}

implement Applicative for Maybe {
  ap (Some f) m = fmap f m
  ap _ _ = None
  pure a = Some a
}

implement Monad for Maybe {
  bind (Some a) k = k a
  bind None _ = None
}

implement Functor for Result {
  fmap f (Ok a) = Ok (f a)
  fmap _ (Err b) = Err b
}

implement Applicative for Result {
  ap (Ok f) a = fmap f a
  ap _ (Err b) = Err b
  pure a = Ok a
}

implement Monad for Result {
  bind (Ok a) k = k a
  bind _ (Err b) = Err b
}

// trait Num n {
//   odd? a, a => a
// }

trait Foldable f { // ok
  fold (a, b: a), a, f b => a // comm
  length xs = fold (acc x: acc + 1) 0 xs
  sum xs = fold (acc n: n + acc) 0 xs
  map l xs = fold (acc x: (acc ++ [l x])) [] xs
  filter f xs = fold (acc x: (f x) ? (acc ++ [x]) : acc) [] xs
  reject f xs = fold (acc x: (f x) ? acc : (acc ++ [x])) [] xs
  product xs = fold (acc n: n * acc) 1 xs
  includes? x xs = fold (acc p: (p == x) ? true : false) false xs
  unique xs = fold (acc x: (includes? x acc) ? acc : (acc ++ [x])) [] xs
  last xs = reverse xs |> head
  find f xs = filter f xs |> head
  reverse xs = fold (acc x: x :: acc) [] xs
  max xs = sort xs |> reverse |> head
  min xs = sort xs |> head
  all? f xs = length (filter f xs) == length xs
  any? f xs = length (filter f xs) > 0
  take n xs = fold (acc o: ((length acc) < n) ? (acc ++ [o]) : acc) [] xs
  drop n xs = reverse xs |> take ((length xs) - n) |> reverse
  toDict xs = fold (acc (k, v): { acc | { k => v } }) {} xs
}

implement Foldable for List {
  fold _ initOrAcc [] = initOrAcc
  fold b initOrAcc (o::os) = fold b (b initOrAcc o) os
}

implement Foldable for String {
  fold _ initOrAcc [] = initOrAcc
  fold c initOrAcc cs = foldString c initOrAcc (HFI toChars [cs])
  foldString _ initOrAcc [] = initOrAcc; foldString f initOrAcc (o::os) = foldString f (f initOrAcc o) os
}

implement Foldable for Dict {
  fold _ initOrAcc [] = initOrAcc
  fold m initOrAcc bs = foldDict m initOrAcc (HFI dictToList [bs])
  foldDict _ initOrAcc [] = initOrAcc
  foldDict b initOrAcc (o::os) = foldDict b (b initOrAcc o) os
  key? z xs = fold (acc (k, _): (k == z) ? true : false) false xs
}

trait Monoid t {
  concat [a] => a
  empty => a
  append a, a => a
}

implement Monoid for String {
  // concat (x::xs) = x :: (concat xs)
  append a b = a :: b
  empty = ""
}

implement Monoid for List {
  // concat (x::xs) = x :: (concat xs)
  append a b = a :: b
  empty = []
}

implement Monoid for Dict {
  // concat (x::xs) = x :: (concat xs)
  append a b = { a | b}
  empty = {}
}

module String {
  join m xs = fold (acc x: (length acc > 0) ? (acc :: m :: x) : x) "" xs
  // * om match första: do nothing
  // * om inte match, lägg till i senaste strängen
  // * om match senare: ny sträng
  // * om match sista: do nothing
  // split m xs = fold (acc c: (x == m) ? acc ++ [c] : acc) [] xs
// * strip
// * capitalize
// * upcase
// * downcas
}

